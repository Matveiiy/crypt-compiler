fn main() {
    y = x = 2 + 3 * 4;
    if (y == 3) {
        while (1) {

        }
    }
}
// после return заигнорить или бросить ошибку
// связывание одинаковых имён
// lvalue(только переменная, . (x.y), [0]) т.е. x.y[0][1].z, rvalue
// кодогенерация


//такое запретить  fn(a) { return x + y + 1; } * 3 - 1
//проверка типов базовая(мб ^^^^)
// (запретить функцию в выражении)
// array,
fn f2() {
// this is a comment
    y = x = 2; // we can write comments!
    if (y == 2) {
        while (y < 2 * 3) {
            y=y+1*x;
        }
    } else if (x == 3) {

    }
    else if (x == 4) {

    }
    else {
        x = 1;
    }
    x[2 * y + 1][1] = 1[2];
    x[2][3*x()[0]] = fn(a){ return a; }[2]();
    x[2][fn(a){return a;}[2[1]]] = fn(a){ return a; }[2]();
    x[2][fn(a){return a;}[b[1]]] = fn(a){ return a; }[2]();
    //      (fn: (x, y) -> x + y + 1) * 3 + 1
    //      fn: (x, y) -> x + y + 1 * 3 + 1
    //z x
    //
    x = 1;
    x = 0;
    x = false;
    x = array(100);
    a = 1;
    b =  2;
    c = 3;
    d = a + b + c;
    y = fn(a) { return a + b + c + d; };
//    return y; - error return should be last
    x = fn(a, b) { a + b; };
    y = x(1, 2);
    x = 2 * 2 + 2;
    x = y = fn(a) { return x + y + 1; } * 3 - 1;
    x = y = x() - 1;
    x = y = fn(a) { x + y + 1; };
    x = y = fn(a, b) { x + y + 1; };
    x = y = fn(a,b,c) { x + y + 1; x(1, x * 2 + 3 * y); return y * 2; };
    z = y * x + 2 * 2;
}

//vector<pair<string, int>> jmps;


fn f() {
    b = 2;
}

fn g() {//10
    gg();//12
    return fff();
    // OP_CALL <16 bit>
}

fn fff() {//340
}

fn main() {//500
    z = f2();
    z();
}
fn h() {//600
    return g();
}
